From d083d2611cce1f88d5830639498aac687b35c418 Mon Sep 17 00:00:00 2001
From: Izak Burger <iburger@victronenergy.com>
Date: Fri, 20 Jun 2025 16:11:03 +0200
Subject: [PATCH] settingsdevice: lighter version to track settings

Before, we used dbus-python's proxy object. This calls
getNameOwner and AddWatch for every proxy object created,
creating quite a bit of dbus traffic. This is a lighter
version that just remembers all the Setting objects, and
if there is a change, propagate it to the right one.
---
 settingsdevice.py | 91 ++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 87 insertions(+), 4 deletions(-)

diff --git a/settingsdevice.py b/settingsdevice.py
index 75260ea..ddd879f 100644
--- a/settingsdevice.py
+++ b/settingsdevice.py
@@ -5,7 +5,7 @@
 
 # Local imports
 from vedbus import VeDbusItemImport
-from ve_utils import unwrap_dbus_value
+from ve_utils import unwrap_dbus_value, wrap_dbus_value
 
 ## Indexes for the setting dictonary.
 PATH = 0
@@ -14,6 +14,89 @@
 MAXIMUM = 3
 SILENT = 4
 
+VE_INTERFACE = "com.victronenergy.BusItem"
+
+## VeDbusSettingItem class, our own proxy that's lighter than what dbus-python has
+class VeDbusSettingItem(object):
+	def __new__(cls, bus, serviceName, path, *args, **kwargs):
+		o = object.__new__(cls)
+
+		# This is called once, when the first VeDbusSettingItem is created
+		if "_tracked" not in VeDbusSettingItem.__dict__:
+			VeDbusSettingItem._tracked = {}
+
+			# Track changes on service
+			bus.add_signal_receiver(VeDbusSettingItem._setting_changed_handler,
+				"PropertiesChanged", dbus_interface=VE_INTERFACE,
+				bus_name=serviceName, path_keyword='path')
+			bus.add_signal_receiver(VeDbusSettingItem._items_changed_handler,
+				"ItemsChanged", dbus_interface=VE_INTERFACE,
+				bus_name=serviceName, path="/")
+
+		return o
+
+	@staticmethod
+	def _setting_changed_handler(change, path=None):
+		try:
+			o = VeDbusSettingItem._tracked[path]
+		except KeyError:
+			pass # Not our setting
+		else:
+			o._value = unwrap_dbus_value(change['Value'])
+			try:
+				t = change['Text']
+			except KeyError:
+				t = str(o._value)
+
+			o._callback(o._servicename, o._path, {
+				'Value': o._value, 'Text': t})
+
+	@staticmethod
+	def _items_changed_handler(items):
+		if not isinstance(items, dict):
+			return
+		for path, changes in items.items():
+			try:
+				o = self._tracked[path]
+				v = changes['Value']
+			except KeyError:
+				continue # Not our setting, or no value
+
+			try:
+				t = changes['Text']
+			except KeyError:
+				t = str(unwrap_dbus_value(v))
+
+			o._value = unwrap_dbus_value(v)
+			o._callback(o._servicename, o._path, { 'Value': o._value, 'Text': t})
+
+	def __init__(self, bus, servicename, path, callback, initial_value=None):
+		self._bus = bus
+		self._servicename = servicename
+		self._path = path
+		self._callback = callback
+		self._value = initial_value
+		self._tracked[path] = self
+
+	def __del__(self):
+		try:
+			del self._tracked[self._path]
+		except (AttributeError, KeyError):
+			pass
+
+	def get_value(self):
+		return self._value
+
+	def set_value(self, v):
+		return self._bus.call_blocking(self._servicename, self._path,
+				dbus_interface=VE_INTERFACE, method='SetValue', signature="v",
+				args=[wrap_dbus_value(v)])
+
+	def set_default(self):
+		return self._bus.call_blocking(self._servicename, self._path,
+				dbus_interface=VE_INTERFACE, method='SetDefault', signature="",
+				args=[])
+
 ## The Settings Device class.
 # Used by python programs, such as the vrm-logger, to read and write settings they
 # need to store on disk. And since these settings might be changed from a different
@@ -76,10 +159,10 @@ def addSettings(self, settings):
 		for r in result:
 			if (error := r["error"]) == 0:
 				setting = lookup[r['path']]
-				busitem = VeDbusItemImport(self._bus, self._dbus_name,
+				busitem = VeDbusSettingItem(self._bus, self._dbus_name,
 					r["path"],
-					eventCallback=partial(self.handleChangedSetting, setting),
-					initialValue = unwrap_dbus_value(r['value']))
+					callback=partial(self.handleChangedSetting, setting),
+					initial_value=unwrap_dbus_value(r['value']))
 				self._settings[setting] = busitem
 				self._values[setting] = busitem.get_value()
 			else:
