From fd870086d8cb1ff8bbaf4a3d63be1914866a8de4 Mon Sep 17 00:00:00 2001
From: Jeroen Hofstee <jhofstee@victronenergy.com>
Date: Mon, 2 Feb 2026 15:55:01 +0100
Subject: [PATCH 2/2] Revert "Virtual Keyboard: get VKB working on rotated
 displays"

This reverts commit 72c7ebbd8ac6a9acb3a2f477d5f31e17914b8cdb.
---
 ApplicationContent.qml    | 26 +++-----------------------
 Main.qml                  | 17 +++++++++--------
 components/InputPanel.qml | 18 +-----------------
 3 files changed, 13 insertions(+), 48 deletions(-)

diff --git a/ApplicationContent.qml b/ApplicationContent.qml
index 8a8bbe7a..5f05471e 100644
--- a/ApplicationContent.qml
+++ b/ApplicationContent.qml
@@ -112,12 +112,9 @@ FocusScope {
 	//
 	// Note this Loader is the top-most layer, to allow the idleModeMouseArea beneath to call
 	// acceptMouseEvent() when clicking outside of the focused text field, to auto-close the Qt VKB.
-	property Loader _vkbLoader: Loader {
+	Loader {
 		id: keyboardHandlerLoader
 
-		parent: root.Overlay.overlay
-		z: 1
-
 		asynchronous: true
 		active: Global.isGxDevice || BackendConnection.needsWasmKeyboardHandler
 
@@ -130,25 +127,8 @@ FocusScope {
 		source: Global.isGxDevice
 				? "qrc:/qt/qml/Victron/VenusOS/components/InputPanel.qml"
 				: "qrc:/qt/qml/Victron/VenusOS/components/WasmVirtualKeyboardHandler.qml"
-
-		property Rotation requiredRotation: Rotation {
-			origin.x: width / 2
-			origin.y: height / 2
-			angle: 90
-		}
-
-		Component.onCompleted: {
-			if (Global.main && Global.main.requiresRotation) {
-				// See issue #2702.
-				// Our workaround is the rotate the overlay layer so that it isn't
-				// clipped by the render geometry, and then counter-rotate the
-				// children (VKB, dialogs), and reposition children to account
-				// for the coordinate system transformations.
-				// We will remove all of this once we get EGLFS working and can
-				// simply rotate the entire surface directly.
-				root.Overlay.overlay.transform = keyboardHandlerLoader.requiredRotation
-			}
-		}
+		parent: Overlay.overlay
+		z: 1
 	}
 
 	// Sometimes, the wasm code may crash. Use a watchdog to detect this and reload the page when necessary.
diff --git a/Main.qml b/Main.qml
index 33836a19..f3b8ddf0 100644
--- a/Main.qml
+++ b/Main.qml
@@ -20,8 +20,6 @@ Window {
 	width: Qt.platform.os != "wasm" ? Theme.geometry_screen_width/scaleFactor : Screen.width/scaleFactor
 	height: Qt.platform.os != "wasm" ? Theme.geometry_screen_height/scaleFactor : Screen.height/scaleFactor
 
-	// Automatically decide if rotation is required (portrait -> landscape)
-	readonly property bool requiresRotation: Global.isGxDevice && root.height > root.width
 	property bool isDesktop: false
 	property real scaleFactor: 1.0
 	onIsDesktopChanged: Global.isDesktop = root.isDesktop
@@ -94,22 +92,25 @@ Window {
 		// show the GUI always centered in the window
 		transformOrigin: Item.Center
 
+		// Automatically decide if rotation is required (portrait -> landscape)
+		readonly property bool requiresRotation: Global.isGxDevice && root.height > root.width
+
 		// Apply rotation
 		transform: Rotation {
 			origin.x: root.width / 2
 			origin.y: root.height / 2
-			angle: root.requiresRotation ? 90 : 0
+			angle: requiresRotation ? 90 : 0
 		}
 
 		// Adjust scale depending on the rotation
-		readonly property real rotatedScale: root.requiresRotation
-			? Math.min(root.width / Theme.geometry_screen_height, root.height / Theme.geometry_screen_width)
-			: Math.min(root.width / Theme.geometry_screen_width, root.height / Theme.geometry_screen_height)
+		readonly property real rotatedScale: requiresRotation ?
+			Math.min(root.width / Theme.geometry_screen_height, root.height / Theme.geometry_screen_width) :
+			Math.min(root.width / Theme.geometry_screen_width, root.height / Theme.geometry_screen_height)
 		scale: rotatedScale
 
 		// Center only if rotated
-		x: root.requiresRotation ? (root.width - Theme.geometry_screen_height * contentItem.scale) / 2 : 0
-		y: root.requiresRotation ? (root.height - Theme.geometry_screen_width * contentItem.scale) / 2 : 0
+		x: requiresRotation ? (root.width - Theme.geometry_screen_height * scale) / 2 : 0
+		y: requiresRotation ? (root.height - Theme.geometry_screen_width * scale) / 2 : 0
 
 		// In WebAssembly builds, if we are displaying on a low-dpi mobile
 		// device, it may not have enough pixels to display the UI natively.
diff --git a/components/InputPanel.qml b/components/InputPanel.qml
index f5e62ba3..7b249766 100644
--- a/components/InputPanel.qml
+++ b/components/InputPanel.qml
@@ -29,8 +29,6 @@ QtVirtualKeyboard.InputPanel {
 
 	readonly property string localeName: Language.currentLocaleName
 
-	readonly property bool requiresRotation: Global.main && Global.main.requiresRotation
-
 	function acceptMouseEvent(item, itemMouseX, itemMouseY) {
 		if (!Qt.inputMethod.visible || !item || !focusedItem) {
 			return false
@@ -49,23 +47,9 @@ QtVirtualKeyboard.InputPanel {
 	}
 
 	visible: Qt.inputMethod.visible || yAnimator.running
-
-	y: requiresRotation ? 312 // manually-found coordinate transform for rpi5, see #2702
-	 : Qt.inputMethod.visible ? Theme.geometry_screen_height - root.height
-	 : Theme.geometry_screen_height
-
-	x: requiresRotation ? 480 // manually-found coordinate transform for rpi5, see #2702
-	 : 0
-
-	transformOrigin: Item.Center
-	transform: Rotation {
-		origin.x: width / 2
-		origin.y: height / 2
-		angle: requiresRotation ? 270 : 0
-	}
+	y: Qt.inputMethod.visible ? Theme.geometry_screen_height - root.height : Theme.geometry_screen_height
 
 	Behavior on y {
-		enabled: !root.requiresRotation
 		YAnimator {
 			id: yAnimator
 			duration: Theme.animation_inputPanel_slide_duration
-- 
2.43.0

