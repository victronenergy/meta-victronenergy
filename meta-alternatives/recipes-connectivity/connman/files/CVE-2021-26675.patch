From dfa45486815cb2e3aa8dcd4b820b70ceb0ceaebc Mon Sep 17 00:00:00 2001
From: Jeroen Hofstee <jhofstee@victronenergy.com>
Date: Wed, 6 Apr 2022 13:59:29 +0200
Subject: [PATCH] dnsproxy: Add length checks to prevent buffer overflow

Author: Colin Wee <cwee@tesla.com>
Fixes: CVE-2021-26675
---
 src/dnsproxy.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/dnsproxy.c b/src/dnsproxy.c
index edf259ab..9e5bb311 100644
--- a/src/dnsproxy.c
+++ b/src/dnsproxy.c
@@ -1755,6 +1755,7 @@ static char *uncompress(int16_t field_count, char *start, char *end,
 			char **uncompressed_ptr)
 {
 	char *uptr = *uncompressed_ptr; /* position in result buffer */
+	char * const uncomp_end = uncompressed + uncomp_len - 1;
 
 	DBG("count %d ptr %p end %p uptr %p", field_count, ptr, end, uptr);
 
@@ -1775,12 +1776,15 @@ static char *uncompress(int16_t field_count, char *start, char *end,
 		 * tmp buffer.
 		 */
 
-		ulen = strlen(name);
-		strncpy(uptr, name, uncomp_len - (uptr - uncompressed));
-
 		DBG("pos %d ulen %d left %d name %s", pos, ulen,
 			(int)(uncomp_len - (uptr - uncompressed)), uptr);
 
+		ulen = strlen(name);
+		if ((uptr + ulen + 1) > uncomp_end) {
+			goto out;
+		}
+		strncpy(uptr, name, uncomp_len - (uptr - uncompressed));
+
 		uptr += ulen;
 		*uptr++ = '\0';
 
@@ -1790,6 +1794,10 @@ static char *uncompress(int16_t field_count, char *start, char *end,
 		 * We copy also the fixed portion of the result (type, class,
 		 * ttl, address length and the address)
 		 */
+		if ((uptr + NS_RRFIXEDSZ) > uncomp_end) {
+			DBG("uncompressed data too large for buffer");
+			goto out;
+		}
 		memcpy(uptr, ptr, NS_RRFIXEDSZ);
 
 		dns_type = uptr[0] << 8 | uptr[1];
-- 
2.25.1

